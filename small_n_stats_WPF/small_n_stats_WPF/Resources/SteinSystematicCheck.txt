# 
#    Copyright 2016 Shawn Gilroy
#
#    This file is part of Demand Analysis.
#
#    Demand Analysis is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 2.
#
#    Demand Analysis is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Demand Analysis.  If not, see <http://www.gnu.org/licenses/gpl-2.0.html>.
#
#    Demand Analysis incorporates source from Beezdemand to compute the following  
#    checks for systematic-ness in purchase task data:
#    TotalPass 
#    DeltaQ 
#    DeltaQPass 
#    Bounce 
#    BouncePass 
#    Reversals 
#    ReversalsPass 
#    NumPosValues
#    
#    ================================================================================
# 
#    Beezdemand is distributed under this license:
#
#    Copyright 2016 Brent Kaplan
#
#    Beezdemand is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 2.
#
#    Beezdemand is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Beezdemand.  If not, see <http://www.gnu.org/licenses/gpl-2.0.html>.
#

SourceFrame <- data.frame(
  p=pLoad,
  y=yLoad,
  x=xLoad)

participants <- unique(SourceFrame$p)
nSimulated <- length(participants)

deltaq = 0.025
bounce = 0.10
reversals = 0
ncons0 = 2

SteinFrame <- data.frame(
  Participant=rep(NA,nSimulated),
  TotalPass=rep(NA,nSimulated),
  DeltaQ=rep(NA,nSimulated),
  DeltaQPass=rep(NA,nSimulated),
  Bounce=rep(NA,nSimulated),
  BouncePass=rep(NA,nSimulated),
  Reversals=rep(NA,nSimulated),
  ReversalsPass=rep(NA,nSimulated),
  NumPosValues=rep(NA,nSimulated))

for (i in seq_len(nSimulated)) 
{
  SteinFrame[i, "Participant"] <- participants[i]
  
  adf <- NULL
  adf <- SourceFrame[SourceFrame$p == participants[i], ]
  
  
  adf[, c("x01", "y01")] <- adf[, c("x", "y")] + .01
  
  SteinFrame[i, "DeltaQ"] <- round((log10(adf[1, "y01"]) - log10(adf[nrow(adf), "y01"])) / (log10(adf[nrow(adf), "x01"]) - log10(adf[1, "x01"])), 4)
  SteinFrame[i, "Bounce"] <- round(sum(diff(adf[, "y"]) > adf[1, "y"] * 0.25, na.rm = TRUE)  / (nrow(adf) - 1), 4)
  
  nrev <- NULL
  if (0 %in% adf[, "y"]) 
  {
    z <- which(adf[, "y"] == 0)
    if (ncons0 == 2) 
	{
        if (any(z > NROW(adf) - 2)) 
	    {
            z <- z[-which(z > NROW(adf) - 2)]
        }

		if (length(z) > 0) 
		{
			for (j in (min(z)):(NROW(adf) - 2)) 
			{
			  if (adf[j, "y"] == 0 && adf[j + 1, "y"] == 0 && adf[j + 2, "y"] != 0) 
			  {
				  nrev[j] <- 1
			  } else 
			  {
				  next
			  }
			}

			SteinFrame[i, "Reversals"] <- sum(nrev, na.rm = TRUE)

		  } else {
			  SteinFrame[i, "Reversals"] <- 0
		  }

		} else 
		{
		    if (ncons0 == 1) 
			{
			    if (any(z > NROW(adf) - 1)) 
				{
			        z <- z[-which(z > NROW(adf) - 1)]
			    }
			
			if (length(z) > 0) 
			{
			  for (j in (min(z)):(NROW(adf) - 1)) 
			  {
				    if (adf[j, "y"] == 0 && adf[j + 1, "y"] != 0) 
				    {
				        nrev[j] <- 1
				    } else 
				    {
				        next
				    }
	  		    }

			    SteinFrame[i, "Reversals"] <- sum(nrev, na.rm = TRUE)

			} else {
			    SteinFrame[i, "Reversals"] <- 0
			}
		}
	  }
  } else {
      SteinFrame[i, "Reversals"] <- 0
  }
  
  SteinFrame[i, "NumPosValues"] <- length(adf[ adf$y != 0, "y"])
  SteinFrame[i, "DeltaQPass"] <- ifelse(SteinFrame[i, "DeltaQ"] >= deltaq, "Pass", "Fail")
  SteinFrame[i, "BouncePass"] <- ifelse(SteinFrame[i, "Bounce"] <= bounce, "Pass", "Fail")
  SteinFrame[i, "ReversalsPass"] <- ifelse(SteinFrame[i, "Reversals"] <= reversals, "Pass", "Fail")
  SteinFrame[i, "TotalPass"] <- length(grep("Pass", SteinFrame[i, ]))
}
