# 
#    Copyright 2016 Shawn Gilroy
#
#    This file is part of Demand Analysis.
#
#    Demand Analysis is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 2.
#
#    Demand Analysis is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Demand Analysis.  If not, see <http://www.gnu.org/licenses/gpl-2.0.html>.
#
#    Demand Analysis incorporates source from Beezdemand to compute the following  
#    demand measures:
#        OmaxE
#        PmaxE
#        Q0e
#        BP0
#        BP1
#        EV
#        OmaxD
#        PmaxD
#
#    ================================================================================
# 
#    Beezdemand is distributed under this license:
#
#    Copyright 2016 Brent Kaplan
#
#    Beezdemand is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 2.
#
#    Beezdemand is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Beezdemand.  If not, see <http://www.gnu.org/licenses/gpl-2.0.html>.
#

SourceFrame <- data.frame(
  p=pLoad,
  y=yLoad,
  x=xLoad,
  k=kLoad)

nSimulated <- length(SourceFrame$p)

fitFrame <- data.frame(
  p=seq(1,nSimulated,1),
  q0=rep(NA,nSimulated),
  q0err=rep(NA,nSimulated),
  alpha=rep(NA,nSimulated),
  alphaerr=rep(NA,nSimulated),
  k=rep(NA,nSimulated),
  r2=rep(NA,nSimulated),
  absSS=rep(NA,nSimulated),
  sdResid=rep(NA,nSimulated),
  q0low=rep(NA,nSimulated),
  q0high=rep(NA,nSimulated),
  alow=rep(NA,nSimulated),
  ahigh=rep(NA,nSimulated),
  OmaxE=rep(NA,nSimulated),
  PmaxE=rep(NA,nSimulated),
  Q0e=rep(NA,nSimulated),
  BP0=rep(NA,nSimulated),
  BP1=rep(NA,nSimulated),
  EV=rep(NA,nSimulated),
  OmaxD=rep(NA,nSimulated),
  PmaxD=rep(NA,nSimulated))

for (i in 1:nSimulated)
{
  dataHolder <- NULL
  dataHolder <- SourceFrame[SourceFrame$p==i,]
  dataHolder[dataHolder$x == 0, ]$x <- 0.01
  dataHolder <- dataHolder[dataHolder$y != 0, ]
  dataHolder$expend <- (dataHolder$x * dataHolder$y)

  ### These measures computed even if model fails/is not appropriate

  fitFrame[fitFrame$p==i,]$OmaxE <- max(dataHolder$expend)
  fitFrame[fitFrame$p==i,]$PmaxE <- max(dataHolder[dataHolder$expend == max(dataHolder$expend),]$x)
  fitFrame[fitFrame$p==i,]$Q0e <- dataHolder[dataHolder$x == min(dataHolder$x),]$y
  
  if (length(dataHolder[dataHolder$y == 0,]$x) > 0)
  {
	fitFrame[fitFrame$p==i,]$BP0 <- min(dataHolder[dataHolder$y == 0,]$x)
  }

  if (sum(dataHolder$y > 0))
  {
	fitFrame[fitFrame$p==i,]$BP1 <- max(dataHolder[dataHolder$y != 0,]$x)
  }

  ###

  fit <- NULL
  try(fit <- wrapnls(data=dataHolder, (log(y)/log(10)) ~ (log(q0)/log(10)) + k * (exp(-alpha*q0*x)-1), start=c(q0=3, alpha=0.000000001), control = list(maxiter = 1000)), silent=TRUE)
  
  if (!is.null(fit))
  {
    fitFrame[fitFrame$p==i,]$q0 <- as.numeric(coef(fit)["q0"])
    fitFrame[fitFrame$p==i,]$alpha <- as.numeric(coef(fit)["alpha"])
    fitFrame[fitFrame$p==i,]$k <- min(dataHolder$k)
    fitFrame[fitFrame$p==i,]$q0err <- summary(fit)[[10]][1,2]
    fitFrame[fitFrame$p==i,]$alphaerr <- summary(fit)[[10]][2,2]
    fitFrame[fitFrame$p==i,]$r2 <- 1.0 -(deviance(fit)/sum((log(dataHolder$y)/log(10)-mean(log(dataHolder$y)/log(10)))^2))
    fitFrame[fitFrame$p==i,]$absSS <- deviance(fit)
    fitFrame[fitFrame$p==i,]$sdResid <- sqrt(deviance(fit)/df.residual(fit))
    fitFrame[fitFrame$p==i,]$q0low <- confint2(fit)[1]
    fitFrame[fitFrame$p==i,]$q0high <- confint2(fit)[3]
    fitFrame[fitFrame$p==i,]$alow <- confint2(fit)[2]
    fitFrame[fitFrame$p==i,]$ahigh <- confint2(fit)[4]
    fitFrame[fitFrame$p==i,]$EV <- 1/(fitFrame[fitFrame$p==i,]$alpha * (fitFrame[fitFrame$p==i,]$k ^ 1.5) * 100)
    fitFrame[fitFrame$p==i,]$PmaxD <- 1/(fitFrame[fitFrame$p==i,]$q0 * fitFrame[fitFrame$p==i,]$alpha * (fitFrame[fitFrame$p==i,]$k ^ 1.5)) * (0.083 * fitFrame[fitFrame$p==i,]$k + 0.65)
    fitFrame[fitFrame$p==i,]$OmaxD <- (10^(log10(fitFrame[fitFrame$p==i,]$q0) + (fitFrame[fitFrame$p==i,]$k * (exp(-fitFrame[fitFrame$p==i,]$alpha * fitFrame[fitFrame$p==i,]$q0 * fitFrame[fitFrame$p==i,]$PmaxD) - 1)))) * fitFrame[fitFrame$p==i,]$PmaxD
  }
}

xDraw <- seq(min(SourceFrame$x), max(SourceFrame$x), 0.01)

p.rep <- seq(1,max(SourceFrame$p),1)

graphFrame<-data.frame(
  Individual=rep(seq(min(p.rep), max(p.rep),1),each=length(xDraw)),
  DemandSeries=rep(seq(1:length(xDraw)-1),length(p.rep)),
  YSeries=rep(seq(1:length(xDraw)-1),length(p.rep)),
  XSeries=rep(seq(1:length(xDraw)-1),length(p.rep))
)

for (j in 1:max(SourceFrame$p))
{
  for (i in 1:length(xDraw))
  {
    qTemp <- fitFrame[fitFrame$p==j,]$q0
    aTemp <- fitFrame[fitFrame$p==j,]$alpha
    kTemp <- fitFrame[fitFrame$p==j,]$k
    
    graphFrame[ graphFrame$Individual==j & graphFrame$DemandSeries==as.numeric(i),]$YSeries <- log10(qTemp) + kTemp * (exp(-aTemp*qTemp*xDraw[i])-1)
    graphFrame[ graphFrame$Individual==j & graphFrame$DemandSeries==as.numeric(i),]$XSeries <- xDraw[i]
  }
}

axis_mod <- function(l) { 
  l <- paste("10^", l, sep = "")  
  parse(text=l) 
} 

pointFrame <- data.frame(X=SourceFrame$x, Y=SourceFrame$y, Individual=SourceFrame$p)

logChart <- ggplot() +
  geom_line(data=graphFrame, aes(x=XSeries, y=YSeries, group=Individual, colour = factor(Individual))) + 
  geom_point(data=pointFrame, aes(x=pointFrame$X, y=log10(pointFrame$Y), shape=factor(Individual))) +
  expand_limits(y=0) +
  theme_bw() +
  theme(panel.grid.minor = element_blank()) +
  ggtitle("Fitted Demand Curves\n") +
  ylab("log(Consumption)") +
  scale_x_log10(
    breaks = scales::trans_breaks("log10", function(x) 10^x),
    labels = scales::trans_format("log10", scales::math_format(10^.x))
  ) + 
  scale_y_continuous(labels=axis_mod) +
  annotation_logticks(sides = "b") +
  xlab("log(Price)") +
  theme(legend.title = element_blank()) +
  theme(legend.position = "none") +
  theme(legend.direction = "vertical") + 
  theme(panel.grid.minor = element_blank()) +
  theme(panel.grid.major = element_blank()) +
  guides(col = guide_legend(ncol = 3))
